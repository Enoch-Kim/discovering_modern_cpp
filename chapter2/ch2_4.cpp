/*
    20-02-14 Enoch Kim
    cpp 교재 <모던 C++입문> 2강
    2.4 ~ 2.5
    db관련 코드는 https://github.com/gilbutITbook/006828/blob/master/c%2B%2B03/occi_old_style.cpp 참고 
*/

/*
    소멸자
    소멸자는 개체를 파괴할 때마다 호출되는 함수
    소멸자 앞에는 ~을 붙이는데 이것은 생성자의 보수 연산을 행하기 때문이다.
    오직 하나의 오버로드만 있고 인수가 없다.

    소멸자 구현규칙
    1. 소멸자에서는 절대로 예외를 던지면 안된다. 프로그램 크래시가 발생하고 예외도 발견할 수 없을 확률이 높다.
    2. 클래스에 virtual함수가 포함되어 있으면 소멸자도 virtual이어야 한다.

    리소스 처리
    소멸자에서는 개체의 리소스(메모리, 파일 핸들, 소켓, 락...)를 해제하고 더 이상 필요하지 않은 개체와 관련된 모든 것들을 정리하는 일을 한다.
    다른 것들도 할 수 있지만. 프로그램의 안정성을 위해 리소스 해제만을 다루는 것이 좋다.

*/

class vector {
    public :
        // ...
        ~vector() {
            delete[] data;
        }
        // ...
    private :
        unsigned my_size;
        double *data;
};
/*
    이미 delete는 포인터가 nullptr인지 여부를 검사한다는 점을 유의하라. 마찬가지로 기존 C 핸들로 연 파일은 명시적으로 닫아야한다.
    (사용하지 않는 이유가 여기에 있다.) => 이게 뭔소린지 모르겠다.

    RAII(Resource Acquisition Is Initialization) 
    리소스를 개체에 묶고 개체 생성 및 파괴 메커니즘을 사용해 프로그램에서 리소스를 자동으로 처리하는 방식.
    리소스를 얻으려고 할때마다 리소스를 소유하는 개체를 만들어 리소스를 얻는다. 
    개체를 벗어날 때마다 리소스를 자동으로 해제한다.

    예외가 발생하면 예외를 던지기 전에 지금까지 획득했던 모든 리소스를 해제해야한다. 
    문제는 현재 스코프 뿐만 아니라 주변 스코프의 리소스까지 해제해주어야한다는 것이다.
    이는 오류 처리를 변경할 때 다른 코드도 변경해야하는 상황을 만든다.

    => 이 모든 문제들의 해결책은 클래스를 도입함으로 해결
    1. C++ 표준 라이브러리들은 리소르를 관리하는 클래스를 제공
    2. unique_ptr과 shared_ptr는 메모리 누수를 방지해주고, 예외를 안전한 방식으로 처리한다.
    3. unique_ptr을 사용하면 소멸자를 구현할 필요가 없다. ***

    스마트포인터로 해결할 수 없는경우(우리의 의도대로 리소스 처리가 안되는 경우)
    => 우리는 필요에따라 리소스를 관리해야한다. 문제는 한 클래스에서 하나 이상의 리소스를 관리해서는 안된다는 것이다.
      이는 생성자에서 예외가 발생할 수 있다는 것과 지금까지 획득한 모든 리소스 해제를 보장하는 방식으로 생성자를 만드는것은 매우 귀찮고 지루하기 때문.
      따라서 우리는 심지어 타입이 같더라도 두 리소스를 처리하는 클래스를 작성할 때마다 리소스 중 하나를 관리하는 클래스를 도입해야한다.
      또한, 두 리소스의 관리자를 작성하고 리소스의 내용과 처리 로직을 완전히 분리해야한다. 이러면 생성자의 중간에 예외가 발생하는 경우에도 관리자의
      소멸자를 자동으로 호출해 처리하므로 누수 문제가 없다.
    
    db example의 경우는 좀있다가 예제를 풀면서 다시보자. (눈으로만 봤으니 코드로 구현해보자 좀있다.)
*/

/*
    메서드 생성규칙
    우리는 6가지 메서드를 가지고 있다.
    1. 디폴트 생성자
    2. 복사 생성자
    3. 이동 생성자 (cpp11)
    4. 복사 할당 연산자
    5. 이동 할당 연산자 (cpp11)
    6. 소멸자
    => 이 6가지 작업을 가능한 한 적게 구현하고 최대한 많이 선언하라. 
    구현되지 않은 작업들은 "default"혹은 "delete"로 선언되어야한다.

    struct foo {
        int a;
        foo() = delete;
    };

    foo f{}; // error use of deleted function foo::foo()
    foo f{3}; // OK
        

*/

int main() {
    return 0;
}